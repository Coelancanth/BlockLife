#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Only run for branch checkouts (not file checkouts)
if [ "$3" = "1" ]; then
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  
  # Skip for main branch
  if [ "$current_branch" = "main" ]; then
    exit 0
  fi
  
  # Fetch latest main silently
  git fetch origin main --quiet 2>/dev/null
  
  # Check how far behind we are
  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo "0")
  
  # Smart notifications based on staleness
  if [ "$behind" -gt 20 ]; then
    echo ""
    echo "ðŸš¨ Branch Health Check: $current_branch"
    echo "   âš ï¸  $behind commits behind main (high merge risk)"
    echo "   "
    echo "   Quick fix options:"
    echo "   1. git rebase origin/main     (recommended - clean history)"
    echo "   2. git merge origin/main      (if rebase is complex)"
    echo ""
  elif [ "$behind" -gt 10 ]; then
    echo ""
    echo "ðŸ“Š Branch Status: $current_branch"
    echo "   âš ï¸  $behind commits behind main"
    echo "   ðŸ’¡ Consider: git rebase origin/main"
    echo ""
  elif [ "$behind" -gt 0 ]; then
    echo ""
    echo "ðŸ“Š Branch Status: $current_branch is $behind commits behind main âœ“"
  fi
  
  # Check for uncommitted Memory Bank changes
  memory_changes=$(git status --porcelain .claude/memory-bank/ 2>/dev/null)
  if [ -n "$memory_changes" ]; then
    echo "   ðŸ“ Uncommitted Memory Bank changes detected"
    echo "      Run: ./scripts/memory-sync.ps1 save"
  fi
  
  # Check if branch has upstream
  upstream=$(git rev-parse --abbrev-ref "$current_branch@{upstream}" 2>/dev/null)
  if [ -z "$upstream" ]; then
    echo "   ðŸ’¡ No upstream set. Push with: git push -u origin $current_branch"
  fi
  
  # Auto-sync Memory Bank on branch switch (if available)
  if [ -f "scripts/memory-sync.ps1" ]; then
    powershell -ExecutionPolicy Bypass -File scripts/memory-sync.ps1 -Operation pull 2>/dev/null || true
  fi
fi