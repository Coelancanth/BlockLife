#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# Only run for branch checkouts (not file checkouts)
if [ "$3" = "1" ]; then
  current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
  
  # Skip for main branch or if branch detection failed
  if [ "$current_branch" = "main" ] || [ "$current_branch" = "unknown" ]; then
    exit 0
  fi
  
  # Fetch latest main silently (with error handling)
  git fetch origin main --quiet 2>/dev/null || true
  
  # Check how far behind we are (with error handling)
  behind=$(git rev-list --count HEAD..origin/main 2>/dev/null || echo "0")
  
  # Smart notifications based on staleness
  if [ "$behind" -gt 20 ]; then
    echo ""
    echo "ðŸš¨ Branch Health Check: $current_branch"
    echo "   âš ï¸  $behind commits behind main (high merge risk)"
    echo "   "
    echo "   Quick fix options:"
    echo "   1. git rebase origin/main     (recommended - clean history)"
    echo "   2. git merge origin/main      (if rebase is complex)"
    echo ""
  elif [ "$behind" -gt 10 ]; then
    echo ""
    echo "ðŸ“Š Branch Status: $current_branch"
    echo "   âš ï¸  $behind commits behind main"
    echo "   ðŸ’¡ Consider: git rebase origin/main"
    echo ""
  elif [ "$behind" -gt 0 ]; then
    echo ""
    echo "ðŸ“Š Branch Status: $current_branch is $behind commits behind main âœ“"
  fi
  
  # Check if branch has upstream (with proper error handling for husky's sh -e)
  upstream=$(git rev-parse --abbrev-ref "$current_branch@{upstream}" 2>/dev/null || echo "")
  if [ -z "$upstream" ]; then
    echo "   ðŸ’¡ No upstream set. Push with: git push -u origin $current_branch"
  fi
  
  # Memory Bank is now local-only per TD_053 - no sync needed
fi