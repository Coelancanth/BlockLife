# BlockLife Development Backlog

**Last Updated**: 2025-08-19

## üìñ How to Use This Backlog

### üß† Owner-Based Ultra-Think Protocol

**Each item has a single Owner persona responsible for decisions and progress.**

#### When You Embody a Persona:
1. **Filter** for items where `Owner: [Your Persona]`
2. **Ultra-Think** if `Status: Proposed` and you're the owner (5-15 min deep analysis)
3. **Quick Scan** for other statuses you own (<2 min updates)
4. **Update** the backlog before ending your session
5. **Reassign** owner when handing off to next persona

#### Ultra-Think Triggers:
- **Automatic**: When you own a "Proposed" item
- **Markers**: [ARCHITECTURE], [ROOT-CAUSE], [SAFETY-CRITICAL], [COMPLEX]
- **Output**: Document decision rationale directly in the item

### Default Ownership Rules
| Item Type | Status | Default Owner | Next Owner |
|-----------|--------|---------------|------------|
| **VS** | Proposed | Product Owner | ‚Üí Tech Lead (breakdown) |
| **VS** | Approved | Tech Lead | ‚Üí Dev Engineer (implement) |
| **BR** | New | Test Specialist | ‚Üí Debugger Expert (complex) |
| **TD** | Proposed | Tech Lead | ‚Üí Dev Engineer (approved) |

### Pragmatic Documentation Approach
- **Quick items (<1 day)**: 5-10 lines inline below
- **Medium items (1-3 days)**: 15-30 lines inline (like VS_001-003 below)
- **Complex items (>3 days)**: Create separate doc and link here

**Rule**: Start inline. Only extract to separate doc if it grows beyond 30 lines or needs diagrams.

### Adding New Items
```markdown
### [Type]_[Number]: Short Name
**Status**: Proposed | Approved | In Progress | Done
**Owner**: [Persona Name]  ‚Üê Single responsible persona
**Size**: S (<4h) | M (4-8h) | L (1-3 days) | XL (>3 days)
**Priority**: Critical | Important | Ideas
**Markers**: [ARCHITECTURE] [SAFETY-CRITICAL] etc. (if applicable)

**What**: One-line description
**Why**: Value in one sentence  
**How**: 3-5 technical approach bullets (if known)
**Done When**: 3-5 acceptance criteria
**Depends On**: Item numbers or None

**[Owner] Decision** (date):  ‚Üê Added after ultra-think
- Decision rationale
- Risks considered
- Next steps
```

## üî• Critical (Do First)
*Blockers preventing other work, production bugs, dependencies for other features*

### BR_006: Parallel Incompatible Features Developed on Different Branches [Score: 95/100]
**Status**: Confirmed
**Owner**: DevOps Engineer
**Size**: M (4-6 hours)
**Priority**: Critical
**Created**: 2025-08-19
**Found By**: Tech Lead during PR #40 merge attempt
**Markers**: [PROCESS] [GIT-WORKFLOW] [DESIGN-CONFLICT]

**What**: Two incompatible game designs (VS_003 merge vs VS_003A-D match) were developed in parallel on different branches
**Why**: Critical process failure - wasted development effort and created unmergeable branches

**The Problem**:
- Main branch implemented VS_003 as "merge" system (PR #39)
- Feature branch implemented VS_003A-D as "match" system (PR #40)
- These are fundamentally incompatible game mechanics
- Both branches have significant work that can't be merged
- No design review caught this before implementation

**Root Cause Analysis**:
1. No design lock before implementation starts
2. Feature branches can diverge significantly from main
3. No requirement to sync with main before major work
4. VS items can be interpreted differently without detection

**Impact**:
- Wasted ~12 hours of development work
- Blocking PR #40 (ADR system)
- Design decision needs escalation
- Team confusion about game direction

**Proposed Solution**:
1. **Immediate**: Design review meeting to choose VS_003 or VS_003A-D
2. **Short-term**: Require design approval before VS implementation
3. **Long-term**: Implement design lock mechanism

**DevOps Actions Required**:
1. Add GitHub branch protection rule: Require up-to-date branches before merge
2. Create design-review workflow: VS items need approval label before coding
3. Add daily main sync requirement for feature branches
4. Create conflict detection GitHub Action
5. Document new workflow in GitWorkflow.md

**Acceptance Criteria**:
- Branch protection prevents outdated merges
- Design review process documented
- GitHub Actions detect design conflicts early
- Team trained on new workflow
- No more parallel incompatible features

**Related**:
- PR #39 (VS_003 merge implementation)
- PR #40 (VS_003A-D match implementation)
- ADR-001 (Pattern Recognition Framework)


## üìà Important (Do Next)
*Core features for current milestone, technical debt affecting velocity*

<<<<<<< HEAD
### VS_003A: Match-3 with Attributes (Phase 1) [Score: 95/100]
**Status**: Approved
**Owner**: Tech Lead ‚Üí Dev Engineer
**Size**: M (6.5 hours - updated estimate)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: None

**What**: Match 3+ adjacent same-type blocks to clear them and earn attributes
**Why**: Proves core resource economy loop before adding complexity

**Tech Lead Decision** (2025-08-19):
‚úÖ **APPROVED for implementation with Pattern Recognition Architecture**

**Architecture Decision**: 
- Implement extensible Pattern Recognition Framework instead of simple match detection
- Patterns are descriptions (what COULD happen) separate from execution (what SHOULD happen)
- Enables future tier-ups, transmutations, and chains without refactoring
- See [ADR-001](../03-Reference/ADR/ADR-001-pattern-recognition-framework.md) for detailed architectural rationale

**Technical Approach**:
1. **Pattern Framework** (1.5h): Core abstractions - IPattern, IPatternRecognizer, IPatternResolver, IPatternExecutor
2. **Match Implementation** (1.5h): MatchPatternRecognizer with flood-fill, MatchPatternExecutor for clearing blocks
3. **Player State** (1h): Domain model for resources/attributes, PlayerStateService for tracking
4. **CQRS Integration** (1h): ProcessPatternsCommand triggered after actions, pattern processing pipeline
5. **Presentation** (0.5h): Simple text UI for attributes display

**Key Implementation Files**:
- `src/Core/Features/Block/Patterns/` - Pattern recognition framework
- `src/Core/Domain/Player/` - Player state domain model  
- `src/Core/Features/Block/Patterns/Recognizers/MatchPatternRecognizer.cs` - Flood-fill implementation
- `src/Core/Features/Block/Patterns/Commands/ProcessPatternsCommand.cs` - CQRS integration

**Testing Requirements**:
- 5 tests for MatchPatternRecognizer (horizontal, vertical, L-shape, T-shape, no-match)
- 3 tests for reward calculations (resource mapping, size bonuses, all block types)
- 3 tests for pattern resolution (priority handling, conflict resolution)
- 2 tests for player state updates

**Updated Estimate**: 6.5 hours (added 1h for pattern framework)

**Rationale for Architecture**:
- Flood-fill is encapsulated in ONE recognizer, not spread through codebase
- New pattern types (tier-up, transmute) plug in without touching existing code
- Testable in isolation - mock recognizers for complex scenarios
- Chains work automatically through recursive pattern detection
- Follows Open/Closed Principle - extensible but stable

**Developer Implementation Guide**:

**Pattern Framework Contracts**:
```csharp
// Core pattern interface - all patterns implement this
public interface IPattern
{
    PatternType Type { get; }              // Match, TierUp, Transmute
    Seq<Vector2Int> Positions { get; }     // Blocks involved
    int Priority { get; }                  // Match=10, TierUp=20, Transmute=30
    IPatternOutcome CalculateOutcome();    // What happens if executed
}

// Recognizer finds patterns at a position
public interface IPatternRecognizer
{
    PatternType SupportedType { get; }
    bool IsEnabled { get; }  // Can be toggled by unlocks
    Seq<IPattern> Recognize(IGridStateService grid, Vector2Int trigger, PatternContext ctx);
}

// Executor applies pattern to game state
public interface IPatternExecutor
{
    Task<Fin<ExecutionResult>> Execute(IPattern pattern, ExecutionContext context);
}
```

**Integration Flow (Step-by-Step)**:
1. Player completes action (move/place) ‚Üí `BlockMovedNotification`
2. `ActionCompletedNotificationHandler` catches notification
3. Handler sends `ProcessPatternsCommand(triggerPosition)`
4. `ProcessPatternsCommandHandler` orchestrates:
   - PatternEngine.FindPatterns() ‚Üí calls all recognizers
   - PatternResolver.Resolve() ‚Üí picks highest priority
   - PatternExecutor.Execute() ‚Üí applies changes
   - Check for chains ‚Üí recursive call if new patterns
5. Publish `PatternProcessedNotification` ‚Üí UI updates

**Flood-Fill Implementation Details**:
```csharp
private Seq<Vector2Int> FloodFill(IGridStateService grid, Vector2Int start, BlockType targetType)
{
    var visited = new HashSet<Vector2Int>();
    var connected = new List<Vector2Int>();
    var stack = new Stack<Vector2Int>();
    
    stack.Push(start);
    
    while (stack.Count > 0 && connected.Count < 100) // Safety limit
    {
        var pos = stack.Pop();
        if (visited.Contains(pos)) continue;
        
        var block = grid.GetBlockAt(pos);
        if (block.IsNone || block.Value.Type != targetType) continue;
        
        visited.Add(pos);
        connected.Add(pos);
        
        // Add orthogonal neighbors (not diagonal)
        foreach (var neighbor in GetOrthogonalNeighbors(pos))
        {
            if (grid.IsValidPosition(neighbor) && !visited.Contains(neighbor))
                stack.Push(neighbor);
        }
    }
    
    return connected.Count >= 3 ? Seq(connected) : Seq<Vector2Int>.Empty;
}
```

**DI Container Registration** (in `BlockLifeServiceRegistration.cs`):
```csharp
// Player state (singleton - one player)
services.AddSingleton<IPlayerStateService, PlayerStateService>();

// Pattern recognition system (scoped per request)
services.AddScoped<IPatternEngine, PatternEngine>();
services.AddScoped<IPatternResolver, PriorityResolver>();

// Register ALL recognizers (they'll be injected as IEnumerable)
services.AddScoped<IPatternRecognizer, MatchPatternRecognizer>();
// Future: services.AddScoped<IPatternRecognizer, TierUpRecognizer>();

// Register executors by type
services.AddScoped<IPatternExecutor, MatchPatternExecutor>();
```

**First Test to Write** (TDD approach):
```csharp
[Fact]
public void Recognize_ThreeHorizontal_ReturnsMatchPattern()
{
    // Arrange
    var grid = new TestGridBuilder()
        .WithBlock(0, 0, BlockType.Work)
        .WithBlock(1, 0, BlockType.Work)
        .WithBlock(2, 0, BlockType.Work)
        .Build();
    
    var recognizer = new MatchPatternRecognizer();
    var context = new PatternContext(null, null, null); // Can be null for basic tests
    
    // Act
    var patterns = recognizer.Recognize(grid, new Vector2Int(1, 0), context);
    
    // Assert
    patterns.Should().ContainSingle();
    var pattern = patterns.First();
    pattern.Type.Should().Be(PatternType.Match);
    pattern.Positions.Should().BeEquivalentTo(new[] {
        new Vector2Int(0, 0),
        new Vector2Int(1, 0),
        new Vector2Int(2, 0)
    });
}
```

**Critical Edge Cases to Handle**:
- **Empty positions**: Skip during flood-fill (GetBlockAt returns None)
- **Grid boundaries**: Always check `IsValidPosition()` before access
- **Overlapping patterns**: Resolver picks highest priority (TierUp > Match)
- **Rapid actions**: Commands queued in MediatR, processed sequentially
- **Pattern at edge**: Works normally (flood-fill handles boundaries)
- **No patterns found**: Return empty Seq, no error
- **Circular dependencies**: Visited set prevents infinite loops

**Common Pitfalls to Avoid**:
‚ùå **DON'T** mutate grid during recognition phase
‚ùå **DON'T** execute patterns inside recognizers
‚ùå **DON'T** couple recognizers to specific executors
‚ùå **DON'T** use mutable collections in patterns
‚ùå **DON'T** throw exceptions - use Fin<T> for errors

‚úÖ **DO** keep patterns immutable (use records)
‚úÖ **DO** test recognizers in complete isolation
‚úÖ **DO** use LanguageExt.Seq for collections
‚úÖ **DO** validate all grid positions before access
‚úÖ **DO** log pattern detection for debugging

**Resource/Attribute Mapping** (for reference):
```csharp
public static class BlockTypeRewards
{
    public static (RewardType type, int amount) GetReward(BlockType blockType) => blockType switch
    {
        BlockType.Work => (RewardType.Resource(ResourceType.Money), 10),
        BlockType.Study => (RewardType.Attribute(AttributeType.Knowledge), 10),
        BlockType.Health => (RewardType.Attribute(AttributeType.Health), 10),
        BlockType.Relationship => (RewardType.Resource(ResourceType.SocialCapital), 10),
        BlockType.Fun => (RewardType.Attribute(AttributeType.Happiness), 10),
        // ... etc for all 9 types
    };
}
```

**Performance Considerations**:
- Flood-fill limited to 100 blocks (prevent runaway)
- Pattern detection runs synchronously (fast enough)
- Cache patterns for same board state (future optimization)
- Use ValueTask for hot paths (if profiling shows need)

**Core Mechanic**:
- Match 3+ adjacent same-type blocks (orthogonal only)
- Matched blocks disappear (no transformation)
- Each block type grants specific resources or attributes:
  - Work ‚Üí Money +10 per block (resource)
  - Study ‚Üí Knowledge +10 per block (attribute)
  - Health ‚Üí Health +10 per block (attribute)
  - Relationship ‚Üí Social Capital +10 per block (resource)
  - Fun ‚Üí Happiness +10 per block (attribute)
  - Sleep ‚Üí Energy +10 per block (attribute)
  - Food ‚Üí Nutrition +10 per block (attribute)
  - Exercise ‚Üí Fitness +10 per block (attribute)
  - Meditation ‚Üí Mindfulness +10 per block (attribute)
- Display current attributes (text UI for now)

**Match Size Bonuses**:
- Match-3: Base rewards (√ó1.0)
- Match-4: √ó1.5 bonus multiplier
- Match-5: √ó2.0 bonus multiplier
- Match-6+: √ó3.0 bonus multiplier

**Done When**:
- Matching 3+ blocks clears them from grid
- Attributes increase based on block types matched
- Current attributes display on screen
- Works for all 9 block types
- 5+ unit tests for match detection
- 3+ tests for attribute calculation

**NOT in Scope**:
- Transformation to higher tiers
- Spending attributes
- Unlocks or progression
- Chain reactions

### VS_003B: Tier System Introduction [Score: 80/100]
**Status**: Proposed
**Owner**: Product Owner ‚Üí Tech Lead
**Size**: S (4-6 hours)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: VS_003A

**What**: Add tier indicators and tier-based reward scaling
**Why**: Introduces progression concept without transformation mechanics

**Core Mechanic**:
- Blocks show tier indicator (T1, T2, T3)
- Higher tier blocks give more resources/attributes when matched:

**Tier Bonuses** (multiplicative):
- Tier 1: √ó1.0 (base)
- Tier 2: √ó3.0 tier bonus
- Tier 3: √ó10.0 tier bonus
- Manual tier-2/3 spawn for testing (debug command)

**Done When**:
- Blocks display tier visually
- Matching higher tiers gives proportional resources/attributes
- Debug commands to spawn specific tiers
- 3+ tests for tier-based calculations

### VS_003C: Unlockable Tier-Up System [Score: 75/100]
**Status**: Proposed
**Owner**: Product Owner ‚Üí Tech Lead
**Size**: M (8-10 hours)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: VS_003B

**What**: Spend resources to unlock tier-up abilities
**Why**: Creates strategic resource management and player agency

**Core Mechanic**:
- Unlock shop UI (simple buttons)
- Spend resources to unlock tier-up abilities:
  - "Unlock Work Tier-Up" - 100 Money (resource)
  - "Unlock Study Tier-Up" - 100 Knowledge (attribute)
- When unlocked: 3 same-type blocks can tier-up to 1 higher tier block
- Player chooses: match for resources/attributes OR tier-up for progression

**Done When**:
- Unlock shop displays available unlocks
- Can spend resources to unlock abilities
- Unlocked tier-ups work alongside matching
- Visual indicator for unlocked abilities
- 5+ tests for unlock system
=======
### VS_003: Triple-Merge System (Same-Type Only) [Score: 85/100]
**Status**: Ready for Dev ‚úÖ
**Owner**: Tech Lead ‚Üí Dev Engineer
**Size**: L (12-16 hours - split into 2 phases)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: None (separate from drag/move)

**What**: Implement Triple Town-style merging - 3 adjacent same-type blocks merge into higher tier
**Why**: Creates strategic gameplay with clear, simple rules that players instantly understand

**Core Mechanic** (Triple Town Model):
- **3+ adjacent blocks** of same type (orthogonal only, not diagonal)
- **Merge triggers** when player moves a block to complete a group of 3+
- **Result appears** at the result position (last-moved block location)
- **Tier progression**: Three Tier-1 blocks ‚Üí One Tier-2 block

**Tech Lead Decision** (2025-08-19):
‚úÖ **APPROVED with architectural refinements**

**Technical Approach**:
- **Event-driven architecture** using MediatR notifications
- **IMergeDetector strategy pattern** for future extensibility
- **Chain-aware from start** (ChainDepth parameter for VS_005)
- **Two-phase implementation** to maintain thin slices

**Architecture Structure**:
```
src/Features/Block/Merge/
‚îú‚îÄ‚îÄ Commands/           # MergeCommand with ChainDepth
‚îú‚îÄ‚îÄ Notifications/      # MergeCompletedNotification, BoardChangedNotification  
‚îú‚îÄ‚îÄ Services/          # IMergeDetector, AdjacentSameTypeMergeDetector
‚îî‚îÄ‚îÄ Models/            # MergeGroup, MergeResult
```

**Phase 1: Core Merge Logic** (6-8 hours):
1. Create IMergeDetector interface and flood-fill implementation
2. Build MergeCommand/Handler with ChainDepth support (default 0)
3. Add MergeCompletedNotification for future chain detection
4. Implement MergeScoreCalculator (pure function)
5. Comprehensive unit tests (flood-fill, boundaries, scoring)

**Phase 2: Event Integration & UI** (6-8 hours):
1. Implement BoardChangedNotification pattern
2. Create MergeDetectionHandler for automatic triggering
3. Add TurnEndNotification (marks action complete)
4. Wire up Godot UI with MergePresenter
5. Simple visual feedback and score display
6. End-to-end integration testing

**Done When**:
- Moving a block to form 3+ adjacent same-type triggers merge
- Transformed block appears at result position (last-moved location)
- Other blocks in merge group disappear with visual effect
- Score increases and displays (simple text for now)
- Works for all 9 block types (same-type only)
- 8+ unit tests covering detection, execution, and edge cases
- Event notifications ready for VS_004/VS_005 integration

**NOT in Scope** (VS_004+ territory):
- Auto-spawn system (that's next)
- Cross-type merging (2 Work + 1 Study combinations)
- Chain reactions/cascading merges (VS_005)
- Complex animations beyond simple disappear
- Undo functionality

**Technical Risks Identified**:
- Concurrent merges ‚Üí Mitigate with sequential processing
- Performance on large grids ‚Üí Cache flood-fill results
- Turn state management ‚Üí Clear TurnStart/TurnEnd notifications

**Next**: Dev Engineer implements Phase 1, then Test Specialist validates before Phase 2
>>>>>>> origin/main

### VS_004: Auto-Spawn System [Score: 75/100]
**Status**: Proposed
**Owner**: Product Owner ‚Üí Tech Lead (for breakdown)
**Size**: S (4-6 hours - straightforward mechanic)
**Priority**: Important
**Created**: 2025-08-19
<<<<<<< HEAD
**Depends On**: VS_003A (need matching to manage spawned blocks)
=======
**Depends On**: VS_003 (need merging to manage spawned blocks)
>>>>>>> origin/main

**What**: Automatically spawn new blocks at TURN START before player acts (Tetris-style)
**Why**: Creates strategic planning - player must account for new block before moving

**Core Mechanic** (UPDATED - Turn-Based):
- **Spawn Trigger**: At TURN START (before player can act)
<<<<<<< HEAD
- **Turn Flow**: Spawn ‚Üí Player sees board ‚Üí Player acts ‚Üí Matches resolve ‚Üí Turn ends
=======
- **Turn Flow**: Spawn ‚Üí Player sees board ‚Üí Player acts ‚Üí Merges resolve ‚Üí Turn ends
>>>>>>> origin/main
- **Spawn Count**: 1 block per turn (adjustable for difficulty later)
- **Spawn Position**: Random empty position
- **Spawn Type**: Random from available block types (weighted distribution)
- **Game Over**: When spawn fails due to no empty positions at turn start

**Implementation Approach**:
- Hook into existing command completion (after move/place/merge)
- Find all empty positions on grid
- If empty positions exist: spawn random block type at random position
- If no empty positions: trigger game over state
- Visual feedback for spawned block (appear animation/effect)

**Spawn Distribution** (initial):
- All 9 block types equally weighted (11.1% each)
- Future: Weight based on life stage or difficulty

**Done When**:
- Block spawns after every player action
- Spawns only on empty positions
- Visual indication of newly spawned block
- Game over triggers when grid is full
<<<<<<< HEAD
- Game over screen with final resources and attributes
=======
- Game over screen with final score
>>>>>>> origin/main
- 5+ unit tests for spawn logic
- 2+ tests for game over detection

**NOT in Scope**:
- Difficulty progression (spawn rate increase)
- Weighted spawn probabilities
- Special spawn patterns or rules
- Power-ups to clear spawned blocks
- Spawn preview/prediction
- Multiple spawns per turn
- Life-stage specific spawn rules

**Product Owner Notes**:
- Start with simplest version - one block per turn
- This creates the core gameplay loop: Act ‚Üí Spawn ‚Üí React
- Game over condition finally makes score meaningful
- Must feel fair - random but not cruel

### VS_005: Chain Reaction System [Score: 90/100]
**Status**: Proposed
**Owner**: Product Owner ‚Üí Tech Lead (for breakdown)
<<<<<<< HEAD
**Size**: M (6-8 hours - builds on VS_003A foundation)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: VS_003A (need basic matching first)

**What**: Add cascading matches that trigger automatically, with exponential resource/attribute bonuses
**Why**: Creates the addictive "YES!" moments that separate good puzzle games from great ones

**Core Mechanic**:
- **Chain Trigger**: After any match completes, check if result can trigger new match
- **Recursive Detection**: Each chain can trigger another chain
- **Chain Bonus**: Base √ó 1 ‚Üí √ó2 ‚Üí √ó4 ‚Üí √ó8 ‚Üí √ó16 (exponential)
=======
**Size**: M (6-8 hours - builds on VS_003 foundation)
**Priority**: Important
**Created**: 2025-08-19
**Depends On**: VS_003 (need basic merging first)

**What**: Add cascading merges that trigger automatically, with exponential scoring multipliers
**Why**: Creates the addictive "YES!" moments that separate good puzzle games from great ones

**Core Mechanic**:
- **Cascade Trigger**: After any merge completes, check if result can trigger new merge
- **Recursive Detection**: Each cascade can trigger another cascade
- **Multiplier System**: Base √ó 1 ‚Üí √ó2 ‚Üí √ó4 ‚Üí √ó8 ‚Üí √ó16 (exponential)
>>>>>>> origin/main
- **Chain Counter**: Display "Chain √ó2!", "Chain √ó3!" etc.
- **Celebration**: Bigger effects for longer chains

**Implementation Approach**:
<<<<<<< HEAD
- After match completes, run match detection on result position
- If new match detected, execute it with increased bonus
- Continue recursively until no more matches possible
- Track chain depth for scoring and display
- Add brief delay between chains for visual clarity

**Resource/Attribute Formula**:
```
Chain 1: 10 resources/attributes √ó 1 = 10
Chain 2: 10 resources/attributes √ó 2 = 20
Chain 3: 10 resources/attributes √ó 4 = 40
Chain 4: 10 resources/attributes √ó 8 = 80
Total for 4-chain: 150 resources/attributes!

Final Formula: (BaseValue √ó BlockCount √ó TierBonus √ó MatchSizeBonus √ó ChainBonus) + Rewards
```

**Done When**:
- Matches automatically trigger follow-up matches
- Resource/attribute bonus increases exponentially per chain
- Chain counter displays during chains
- Visual delay between chain steps (player can follow what happened)
- Different sound effects for each chain level
- 5+ unit tests for chain detection
- 3+ tests for bonus calculation
- 2+ tests for recursive chain limits
=======
- After merge completes, run merge detection on result position
- If new merge detected, execute it with increased multiplier
- Continue recursively until no more merges possible
- Track chain depth for scoring and display
- Add brief delay between cascades for visual clarity

**Scoring Formula**:
```
Chain 1: 10 points √ó 1 = 10
Chain 2: 10 points √ó 2 = 20
Chain 3: 10 points √ó 4 = 40
Chain 4: 10 points √ó 8 = 80
Total for 4-chain: 150 points!
```

**Done When**:
- Merges automatically trigger follow-up merges
- Score multiplier increases exponentially per chain
- Chain counter displays during cascades
- Visual delay between cascade steps (player can follow what happened)
- Different sound effects for each chain level
- 5+ unit tests for cascade detection
- 3+ tests for multiplier calculation
- 2+ tests for recursive cascade limits
>>>>>>> origin/main

**NOT in Scope**:
- Special chain-only blocks
- Chain preview/planning UI
- Undo for chains
- Chain-specific animations (use simple for now)
- Maximum chain bonuses/achievements
- Chain-triggered special events

**Critical Design Decisions**:
<<<<<<< HEAD
- **Delay Between Chains**: 0.3-0.5 seconds (fast enough to feel smooth, slow enough to see)
- **Max Chain Depth**: Unlimited (let players find crazy combos)
- **Bonus Cap**: No cap initially (see how high players can go)
=======
- **Delay Between Cascades**: 0.3-0.5 seconds (fast enough to feel smooth, slow enough to see)
- **Max Chain Depth**: Unlimited (let players find crazy combos)
- **Multiplier Cap**: No cap initially (see how high players can go)
>>>>>>> origin/main

**Product Owner Notes**:
- This is THE feature that makes match-3 games addictive
- Must feel satisfying - sound/visual feedback crucial
<<<<<<< HEAD
- Exponential bonuses reward elaborate setups
- Creates skill gap between new and experienced players
- Watch for degenerate strategies (infinite chains)
=======
- Exponential scoring rewards elaborate setups
- Creates skill gap between new and experienced players
- Watch for degenerate strategies (infinite chains)

### TD_016: Update All Documentation for Glossary Consistency [Score: 30/100]
**Status**: Approved ‚úÖ
**Owner**: Tech Lead ‚Üí Dev Engineer
**Size**: S (2-3 hours)
**Priority**: Important (do before VS_003)
**Created**: 2025-08-19
**Markers**: [DOCUMENTATION] [CONSISTENCY]

**What**: Update all documentation to use glossary terms consistently
**Why**: Inconsistent terminology in personas and docs creates confusion

**Tech Lead Decision** (2025-08-19):
‚úÖ **APPROVED - Critical for VS_003 clarity**
- Backlog itself has inconsistencies (e.g., "level" instead of "tier")
- Persona docs will generate wrong variable names
- Must be done before VS_003 implementation

**Scope of Changes**:
- **Persona docs** (6 files): Update terminology in all persona descriptions
- **Backlog items**: Ensure VS/TD/BR descriptions use correct terms
- **Architecture docs**: Align with glossary vocabulary
- **README/Workflow**: Check for terminology mismatches

**Key Replacements Needed**:
- "match" ‚Üí "merge"
- "level" (for blocks) ‚Üí "tier"
- "round" ‚Üí "turn"
- "cell/slot/tile" ‚Üí "position"
- "combo/cascade" ‚Üí "chain"
- "spawn" (for merge results) ‚Üí "transform"
- "trigger position" ‚Üí "result position"

**Approach**:
1. Grep for anti-pattern terms across Docs/
2. Update each file with correct glossary terms
3. Special attention to persona docs (they guide behavior)
4. Update code comments if found

**Done When**:
- All persona docs use glossary terms
- No anti-pattern terms in active documentation
- Backlog items updated for consistency
- Quick reference guide reflects proper vocabulary

**Tech Lead Note**: This is housekeeping but critical - personas using wrong terms will generate wrong code.

>>>>>>> origin/main


## üí° Ideas (Do Later)
*Nice-to-have features, experimental concepts, future considerations*

<<<<<<< HEAD
### VS_003: Triple-Match System (Original - Archived) [Score: 85/100]
**Status**: Archived - Replaced by VS_003A-D phased approach
**Owner**: N/A (Archived)
**Size**: L (12-16 hours - split into 2 phases)
**Priority**: Ideas
**Created**: 2025-08-19
**Archived**: 2025-08-19
**Depends On**: None (separate from drag/move)

**What**: Original design mixing match and tier-up mechanics without clear separation
**Why**: Creates strategic gameplay with clear, simple rules that players instantly understand

**Note**: Replaced by VS_003A-D phased approach that properly separates:
- VS_003A: Match for resources/attributes
- VS_003B: Tier system introduction
- VS_003C: Unlockable tier-up mechanics
- VS_003D: Cross-type transmutation

### VS_003D: Cross-Type Transmutation System [Score: 60/100]
**Status**: Proposed
**Owner**: Product Owner ‚Üí Tech Lead
**Size**: M (6-8 hours)
**Priority**: Ideas (future)
**Created**: 2025-08-19
**Depends On**: VS_003C

**What**: Unlock special cross-type transmutations
**Why**: Adds strategic depth through type conversion

**Core Mechanic**:
- Expensive unlocks for transmutation recipes:
  - Work + Work + Study ‚Üí Career (500 Money + 300 Knowledge)
  - Health + Health + Fun ‚Üí Wellness (300 Health + 200 Happiness)
- Different from tier-up: Changes block TYPE not TIER
- Creates special blocks with unique properties

**Done When**:
- Unlock shop displays transmutation recipes
- Can spend resources to unlock transmutation abilities
- Transmutation works alongside matching and tier-up
- Visual indication of transmuted block types
- 5+ tests for transmutation system

### TD_014: Add Property-Based Tests for Swap Mechanic [Score: 40/100]
=======
### TD_014: Add Property-Based Tests for Swap Mechanic [Score: 45/100]
>>>>>>> origin/main
**Status**: Approved - Immediate Part Ready
**Owner**: Test Specialist  
**Size**: XS (immediate) + M (future property suite)
**Priority**: Ideas (not critical path)
**Created**: 2025-08-19
**Proposed By**: Test Specialist
**Markers**: [QUALITY] [TESTING]

**What**: Implement FSCheck property tests for swap operation invariants
**Why**: Catch edge cases that example-based tests might miss, ensure mathematical properties hold

**Tech Lead Decision** (2025-08-18):
‚úÖ **APPROVED with modifications - Defer to after MVP**

**Analysis**:
- Current swap has only 2 example-based tests
- Property tests would catch edge cases we haven't thought of
- FSCheck is mature and well-suited for game logic invariants
- Swap operation has clear mathematical properties to verify

**However**: 
- We have only 2 swap tests currently - not enough surface area yet
- Property tests shine when you have complex state spaces
- Current swap is relatively simple (range check + position swap)

**Modified Approach**:
1. **Immediate** (5 min): Add 2-3 more example-based tests for critical cases:
   - Swap with boundary blocks (edge of grid)
   - Failed swap attempts (out of range) 
   - Swap with same block (should fail gracefully)
   
**Test Specialist Assignment** (2025-08-18):
‚úÖ **READY FOR IMPLEMENTATION** - Tech Lead analysis complete, Test Specialist to implement
- Current swap tests: 2 existing (CompleteDrag_ToOccupiedPosition_WithinRange_ShouldSwapBlocks, CompleteDrag_SwapAtMaxRange_ShouldSucceed)
- Missing coverage: boundary cases, same-block swaps, edge validation
- Test file location: `tests/BlockLife.Core.Tests/Features/Block/Drag/DragCommandTests.cs`
- Follow existing test patterns using BlockBuilder and FluentAssertions

2. **After MVP** (when swap gets complex):
   - Implement full property-based test suite
   - Add generators for game states
   - Test invariants across all block operations

**Rationale**:
- Property tests are valuable but premature optimization now
- With only 2 tests, we need basic coverage first
- When swap mechanics get complex (power-ups, constraints), revisit

**Proposed Properties** (Future Implementation):
```csharp
// 1. Swap preserves total block count
[Property]
public Property SwapOperation_PreservesBlockCount()

// 2. Swap validation is symmetric
[Property]
public Property SwapDistance_IsSymmetric()
// If A can swap with B, then B can swap with A

// 3. Double swap returns to original state
[Property]
public Property DoubleSwap_ReturnsToOriginal()
// Swapping twice = identity operation
```

**Done When**:
- **Immediate**: 2-3 additional example tests added and passing
- **Future**: Property tests integrated with 1000+ generated cases
- Edge cases discovered are documented
- CI pipeline includes property test execution



### TD_009: Refine Persona Command Implementation for Production [Score: 40/100]
**Status**: Approved ‚úì
**Owner**: DevOps Engineer
**Size**: M (4-6 hours)  
**Priority**: Ideas
**Found By**: DevOps Engineer during persona system testing
**Created**: 2025-08-18

**Tech Lead Decision** (2025-08-18):
‚úÖ APPROVED - Valid improvements but not urgent
- Do after critical items (TD_003, TD_004)
- Focus on error handling and silent mode

**What**: Improve persona command system robustness and user experience
**Why**: Current implementation works but needs refinement for reliable production automation

**Current Issues**:
- Local vs global config precedence unclear and inconsistent
- No error handling for corrupted state files
- Manual testing required to verify which config is active
- Command output verbose for status line usage

**Approach**:
- Add config detection and validation to persona commands
- Implement graceful error handling for missing/corrupted state files
- Create diagnostic commands to show active configuration
- Add silent mode for status line integration (no console output)
- Document config precedence rules clearly

**Technical Improvements**:
- Add `--quiet` flag for status line usage
- Validate .claude/current-persona file format
- Add config source detection (global vs local)
- Implement fallback behavior for missing configs

**Done When**:
- Commands work reliably regardless of config setup
- Clear error messages for configuration issues
- Silent mode works properly with ccstatusline
- Documentation explains config precedence clearly
- No false negatives in persona detection

## üöß Currently Blocked
*None*

## ‚úÖ Recently Completed

<<<<<<< HEAD
*No recent completions. Older completed items have been moved to Archive for reference.*
=======
### VS_002: Translate Creative Brainstorms into Feature Specifications [Score: 30/100]
**Status**: ‚úÖ Completed
**Owner**: Product Owner
**Size**: L (2-3 days)
**Priority**: Ideas
**Created**: 2025-08-19
**Completed**: 2025-08-18
**Depends On**: None

**What**: Translate Chinese brainstorming content into actionable VS items and feature specifications
**Why**: Valuable creative vision needs to be transformed into implementable features

**COMPLETED WORK**:
- ‚úÖ Reviewed all brainstormA/B/C.md files and extracted key concepts
- ‚úÖ Successfully consolidated all creative content into Vision.md
- ‚úÖ Added new systems: Character Origins & Talents, Regional Gameplay, Memory Palace
- ‚úÖ Integrated Inner Monologue System, Narrative Anchor Choices, Time Budget System
- ‚úÖ Added Game Modes (Authentic/Destiny/Legacy) and Generational Legacy System
- ‚úÖ Removed redundant brainstorm files after consolidation
- ‚úÖ Updated documentation references for consistency

**Key Features Integrated**:
- ‚úÖ Emotional time flow (Dynamic Time Scale)
- ‚úÖ Relationship blocks with visual bonds (Bond Links)
- ‚úÖ Personality development through actions (MBTI System)
- ‚úÖ Life stage-specific block types (All Life Stages)
- ‚úÖ Legacy and memory systems (Memory Palace, Generational Legacy)

**Product Owner Note**: All valuable creative vision from Chinese brainstorms has been successfully integrated into the consolidated Vision.md. The game design is now comprehensive and ready for implementation prioritization.

### TD_015: Create Ubiquitous Language Glossary [Score: 20/100]
**Status**: ‚úÖ Completed
**Owner**: Tech Lead
**Size**: XS (30 minutes)
**Priority**: Important
**Created**: 2025-08-19
**Completed**: 2025-08-19

**What**: Create lean glossary defining core game terms
**Why**: Prevent terminology confusion across team and code

**Tech Lead Implementation**:
‚úÖ Created `Docs/03-Reference/Glossary.md` with essential terms
‚úÖ Defined clear vocabulary for turns, actions, blocks, merges
‚úÖ Included code references for each term
‚úÖ Added usage examples and anti-patterns
‚úÖ Distinguished "spawn" (new blocks) from "transform" (merge results)

**Key Terms Defined**:
- **Turn**: Complete cycle from spawn to action resolution
- **Action**: Player-initiated board change
- **Merge**: 3+ adjacent same-type combining
- **Transform**: Merge result creating higher tier (not "spawn")
- **Chain**: Sequential merges from one action
- **Trigger Position**: Where transformed block appears
- **Tier**: Block tier (1-9), not "level"

**Impact**: 
- VS_003-005 can now use consistent terminology
- Code reviews have authoritative reference
- Prevents "what do you mean by X?" discussions
>>>>>>> origin/main

---

## üìã Quick Reference

**Priority Decision Framework:**
1. **Blocking other work?** ‚Üí üî• Critical
2. **Current milestone?** ‚Üí üìà Important  
3. **Everything else** ‚Üí üí° Ideas

**Work Item Types:**
- **VS_xxx**: Vertical Slice (new feature) - Product Owner creates
- **BR_xxx**: Bug Report (investigation) - Test Specialist creates, Debugger owns
- **TD_xxx**: Technical Debt (refactoring) - Anyone proposes ‚Üí Tech Lead approves

*Notes:*
- *Critical bugs are BR items with üî• priority*
- *TD items need Tech Lead approval to move from "Proposed" to actionable*

---
*Single Source of Truth for all BlockLife development work. Simple, maintainable, actually used.*